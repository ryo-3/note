# タグ新規作成時のキャッシュ更新問題の修正

## 問題の概要

メモエディターでタグを新規作成してメモに紐づけた際、メモ一覧側でそのタグが反映されず、画面を更新（リロード）しないと表示されない問題が発生していた。

既存タグの選択時は正常に動作していたため、新規タグ作成時のみの問題であることが判明。

## 原因の詳細分析

### React QueryのキャッシュキーによるデータGive

タグデータを取得する`useTags()`フックが、異なるオプションで呼び出されることによって、別々のキャッシュキーでデータを管理していた：

1. **TagSelector**: `useTags({ search: searchText, sort: 'usage', limit: 50 })`
   - キャッシュキー: `['tags', { search: '...', sort: 'usage', limit: 50 }]`

2. **memo-screen**: `useTags()`
   - キャッシュキー: `['tags', {}]`

### 問題のあった処理フロー

1. TagSelectorで新規タグ作成
2. `useCreateTag`の`onSuccess`で`['tags']`キャッシュを更新
3. しかし、検索オプション付きのキャッシュのみが更新され、基本キャッシュ`['tags', {}]`は更新されない
4. memo-screenは基本キャッシュを参照するため、新規タグが反映されない

### 確認したログデータ

```
use-tags.ts:56 📝 タグキャッシュ更新後: (2) [{…}, {…}]  // TagSelector側は更新
memo-screen.tsx:144 📋 メモ一覧側データ: {tags: Array(15)}  // memo-screen側は未更新
```

## 修正方法

### 選択した解決策：新規作成時のみ全キャッシュ無効化

既存タグの選択・更新・削除は高速なキャッシュ更新を維持し、新規作成時のみ全キャッシュを無効化してAPI再取得を促す方式を採用。

### 修正コード

**apps/web/src/hooks/use-tags.ts**

```javascript
export function useCreateTag() {
  const queryClient = useQueryClient()
  const { getToken } = useAuth()

  return useMutation({
    mutationFn: async (tagData: CreateTagData) => {
      const token = await getToken()
      const response = await tagsApi.createTag(tagData, token || undefined)
      const data = await response.json()
      return data as Tag
    },
    onSuccess: (newTag) => {
      // 新規タグ作成時は複数のキャッシュキーに影響するため、全て無効化して再取得を促す
      queryClient.invalidateQueries({ queryKey: ['tags'] })
      queryClient.invalidateQueries({ queryKey: ['taggings', 'all'] })
    },
  })
}
```

### 修正前後の比較

**修正前**：

- 個別キャッシュ更新を試行
- 複数のキャッシュキーに対応できず不整合発生
- 新規タグがメモ一覧に反映されない

**修正後**：

- 新規作成時のみ全キャッシュ無効化
- 既存タグ操作は従来通り高速キャッシュ更新
- 新規タグが即座にメモ一覧に反映

## 検証結果

修正後のログで正常な動作を確認：

```
use-tags.ts:46 🔄 新規タグ作成成功、全キャッシュ無効化: {id: 18, name: '999'}
memo-screen.tsx:144 📋 メモ一覧側データ: {tags: Array(17)}  // 修正前
memo-screen.tsx:144 📋 メモ一覧側データ: {tags: Array(18)}  // 修正後：1個増加
```

## 学んだポイント

1. **React Queryのキャッシュキー設計の重要性**
   - 同じデータでも異なるオプションで取得すると別キャッシュになる
   - 複数のキャッシュキーを考慮した更新戦略が必要

2. **パフォーマンスと整合性のトレードオフ**
   - 個別更新：高速だが複雑で不整合リスク
   - 全無効化：確実だが再取得コスト

3. **頻度による使い分けの有効性**
   - 頻繁な操作：キャッシュ更新で高速化
   - 稀な操作：無効化で確実性重視

## ファイル変更履歴

- `apps/web/src/hooks/use-tags.ts`: useCreateTagのonSuccessを全キャッシュ無効化に変更
- デバッグログの追加・コメントアウト（tag-selector.tsx, memo-screen.tsx）

## 関連する技術要素

- React Query
- キャッシュ管理
- リアルタイムデータ更新
- フロントエンド状態管理
