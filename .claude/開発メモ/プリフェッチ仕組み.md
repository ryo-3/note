# プリフェッチ仕組み ✅ **実装完了**

## 概要
メモ一覧でのタグ表示機能を実装。ボード名表示と同じ仕組みでプリフェッチとキャッシュを活用し、パフォーマンスを最適化。

## データ取得の流れ

### 1. メイン画面（MemoScreen）
```typescript
// 1. メモデータを取得
const { data: memos } = useMemos();

// 2. プリフェッチャーでボードとタグを事前取得（ちらつき防止）
<ItemBoardsPrefetcher type="memo" items={memos} />
<ItemTagsPrefetcher type="memo" items={memos} />
```

**TaskScreen でも同様**:
```typescript
// タスク一覧のボード情報をプリフェッチ（タグはまだ未実装）
<ItemBoardsPrefetcher type="task" items={tasks} />
```

### 2. プリフェッチ実装（ボード名）

#### ItemBoardsPrefetcher
```typescript
// apps/web/components/shared/item-boards-prefetcher.tsx
export default function ItemBoardsPrefetcher({ type, items }: ItemBoardsPrefetcherProps) {
  // プリフェッチ用のアイテムリスト作成（id のみ抽出）
  const prefetchItems = useMemo(() => {
    return items?.map(item => ({ id: item.id })) || [];
  }, [items]);

  // プリフェッチ実行（副作用のみ、レンダリングなし）
  usePrefetchItemBoards(type, prefetchItems);
  return null; // UIは持たない
}
```

#### usePrefetchItemBoards フック
```typescript
// apps/web/src/hooks/use-boards.ts (583-628行)
export function usePrefetchItemBoards(itemType: 'memo' | 'task', items: { id: number }[] | undefined) {
  const { getToken, isLoaded } = useAuth();

  return useQueries({
    queries: (items || []).map(item => ({
      queryKey: ["item-boards", itemType, item.id],
      queryFn: async () => {
        // 最大2回リトライ（401エラー対応）
        for (let attempt = 0; attempt < 2; attempt++) {
          const token = await getCachedToken(getToken);
          
          const response = await fetch(`${API_BASE_URL}/boards/items/${itemType}/${item.id}/boards`, {
            headers: {
              "Content-Type": "application/json",
              ...(token && { Authorization: `Bearer ${token}` }),
            },
          });
          
          // 401エラーの場合はキャッシュをクリアしてリトライ
          if (response.status === 401 && attempt === 0) {
            cachedToken = null;
            tokenExpiry = 0;
            continue;
          }
          
          if (!response.ok) {
            // 404エラーは空配列を返す（削除済みアイテムなど）
            if (response.status === 404) {
              return [];
            }
            throw new Error("Failed to fetch item boards");
          }

          return await response.json();
        }
        
        throw new Error('Failed after retry');
      },
      enabled: !!items && items.length > 0 && isLoaded, // 認証完了まで待機
      staleTime: 5 * 60 * 1000,      // 5分間キャッシュ（タグより長め）
      refetchOnMount: false,         // マウント時の再取得を無効化
      refetchOnWindowFocus: false,   // ウィンドウフォーカス時の再取得を無効化
    }))
  });
}
```

### 3. プリフェッチ実装（タグ情報）

#### ItemTagsPrefetcher
```typescript
// apps/web/components/shared/item-tags-prefetcher.tsx
export default function ItemTagsPrefetcher({ 
  type, 
  items 
}: { 
  type: 'memo' | 'task' | 'board'; 
  items: Array<{ id: number; originalId?: string }> | undefined;
}) {
  // プリフェッチ用のアイテムリスト作成
  const prefetchItems = useMemo(() => {
    return items?.map(item => ({ id: item.id })) || [];
  }, [items]);

  // usePrefetchItemTags で全アイテムのタグ情報を並列プリフェッチ
  usePrefetchItemTags(type, prefetchItems);
  return null; // UIは持たない
}
```

#### usePrefetchItemTags フック
```typescript
// apps/web/src/hooks/use-taggings.ts (111-140行)
export function usePrefetchItemTags(
  itemType: 'memo' | 'task' | 'board', 
  items: { id: number; originalId?: string }[] | undefined
) {
  const { getToken, isLoaded } = useAuth();

  return useQueries({
    queries: (items || []).map(item => {
      const targetOriginalId = item.originalId || item.id.toString()
      return {
        queryKey: ['taggings', { targetType: itemType, targetOriginalId }],
        queryFn: async () => {
          const token = await getToken()
          const response = await taggingsApi.getTaggings(
            token || undefined,
            itemType,
            targetOriginalId
          )
          if (!response.ok) {
            throw new Error(`Failed to fetch item tags: ${response.status}`)
          }
          const data = await response.json()
          return data as Tagging[]
        },
        enabled: isLoaded && !!items,
        staleTime: 2 * 60 * 1000,     // 2分間は新鮮なデータとして扱う
        gcTime: 10 * 60 * 1000,       // 10分間キャッシュを保持
        refetchOnWindowFocus: false,  // ウィンドウフォーカス時の再取得を無効化
        refetchOnMount: false,        // マウント時の再取得を無効化
      }
    })
  })
}
```

### 4. 個別アイテムでの取得（キャッシュから高速取得）

#### MemoListItem でのボード名取得
```typescript
// apps/web/components/features/memo/memo-list-item.tsx
// ボード名を取得（常にキャッシュから取得、表示は条件で制御）
const itemId = isDeleted ? (memo as DeletedMemo).originalId : memo.id;
const { data: boards } = useItemBoards('memo', !isDeleted ? Number(itemId) : undefined);
```

#### MemoListItem でのタグ取得
```typescript
// メモエディターと同じoriginalId取得ロジックを使用
const targetOriginalId = !isDeleted && memo.id > 0 
  ? ((memo as Memo).originalId || memo.id.toString())
  : '';

// キャッシュからタグデータを高速取得
const { tags } = useItemTags('memo', targetOriginalId);
```

#### TaskListItem でのボード名取得
```typescript
// apps/web/components/features/task/task-list-item.tsx
// ボード名を取得（showBoardNameがtrueの場合のみ）
const { data: boards } = useItemBoards('task', showBoardName ? task.id : undefined);
```

### 5. タグ表示ロジック
```typescript
// ボード名の右側にタグを表示
{/* ボード名・タグ表示 */}
{((showBoardName && boards && boards.length > 0) || (showTags && !isDeleted)) && (
  <div className="mb-1 flex items-center gap-2">
    {/* ボード名 */}
    {showBoardName && boards && boards.length > 0 && (
      <div className="flex flex-wrap gap-1">
        {boards.map(board => <BoardBadge />)}
      </div>
    )}
    
    {/* タグ表示 */}
    {showTags && !isDeleted && (
      <div className="flex flex-wrap gap-1">
        {tags && tags.length > 0 ? (
          tags.map(tag => <TagBadge />)
        ) : (
          <span className="text-xs text-gray-400">タグなし</span>
        )}
      </div>
    )}
  </div>
)}
```

## UI実装

### 1. コントロールパネルのタグ表示トグル
```typescript
// apps/web/components/ui/buttons/tag-display-toggle.tsx
<TagDisplayToggle
  showTags={showTagDisplay}
  onToggle={setShowTagDisplay}
  buttonSize="size-7"
  iconSize="size-4"
/>
```

### 2. タグバッジのスタイル
```typescript
// TAG_COLORS 定数を使用した統一スタイル
<span
  className="inline-flex items-center px-1.5 py-0.5 rounded-full text-xs font-medium"
  style={{
    backgroundColor: TAG_COLORS.background, // #e8dcc0 ベージュ
    color: TAG_COLORS.text                  // #4a3018 茶色
  }}
>
  {tag.name}
</span>
```

### 3. 表示制御
- **コントロールパネル**: メモモードでのみタグ表示トグル表示
- **一覧表示**: リストビュー + タグ表示ON + 削除済みメモでない場合のみ表示
- **位置**: ボード名バッジの右側に横並び表示

## パフォーマンス最適化

### キャッシュ戦略の詳細

| データ種別 | staleTime | gcTime | 理由 |
|------------|-----------|--------|------|
| **ボード名** | 5分間 | 10分間 | 変更頻度が低い、安定したデータ |
| **タグ情報** | 2分間 | 10分間 | 変更頻度が高い、リアルタイム性重視 |

#### グローバル設定（query-client.tsx）
```typescript
defaultOptions: {
  queries: {
    staleTime: 5 * 60 * 1000,     // 5分間は新鮮なデータとして扱う
    gcTime: 30 * 60 * 1000,       // 30分間キャッシュを保持
    refetchOnWindowFocus: false,  // ウィンドウフォーカス時の再取得を無効化
    refetchOnMount: true,         // マウント時の再取得（必要時のみ）
    refetchOnReconnect: true,     // 再接続時の再取得（必要時のみ）
  },
}
```

### N+1問題の解決
- ✅ 各ListItemが個別にAPIリクエストを送ることを防止
- ✅ Prefetcher で一括プリフェッチしてキャッシュに保存
- ✅ 個別フック（useItemBoards/useItemTags）でキャッシュから高速取得

### 認証とエラーハンドリング

#### トークンキャッシュ仕組み
```typescript
// apps/web/src/hooks/use-boards.ts
let cachedToken: string | null = null;
let tokenExpiry = 0;

async function getCachedToken(getToken: () => Promise<string | null>): Promise<string | null> {
  const now = Date.now();
  
  // キャッシュが有効な場合はそれを返す（1分間）
  if (cachedToken && tokenExpiry > now) {
    return cachedToken;
  }
  
  // 新しいトークンを取得
  const token = await getToken();
  if (token) {
    cachedToken = token;
    tokenExpiry = now + 60 * 1000; // 1分間キャッシュ
  }
  
  return token;
}
```

#### リトライ機能（ボード名のみ実装済み）
```typescript
// 最大2回リトライ
for (let attempt = 0; attempt < 2; attempt++) {
  const token = await getCachedToken(getToken);
  
  // API 呼び出し
  const response = await fetch(...);
  
  // 401エラーの場合はキャッシュをクリアしてリトライ
  if (response.status === 401 && attempt === 0) {
    cachedToken = null;
    tokenExpiry = 0;
    continue;
  }
  
  // 404エラーは空配列を返す（削除済みアイテムなど）
  if (response.status === 404) {
    return [];
  }
}
```

### ちらつき防止の工夫

#### useItemBoards での placeholderData
```typescript
// apps/web/src/hooks/use-boards.ts (461-502行)
export function useItemBoards(itemType: 'memo' | 'task', itemId: number | undefined) {
  return useQuery<Board[]>({
    queryKey: ["item-boards", itemType, itemId],
    queryFn: async () => { /* ... */ },
    enabled: !!itemId,
    placeholderData: keepPreviousData, // 前のデータを保持してちらつき防止
  });
}
```

#### プリフェッチのタイミング最適化
- **実行タイミング**: メモ/タスクデータ取得と同時
- **enabled 条件**: `isLoaded && !!items` で認証完了まで待機
- **依存関係**: `useMemo` でアイテムリスト変更時のみ再計算

### originalId の統一
問題があった部分：
```typescript
// ❌ 間違い: memo-list-item で itemId.toString() を使用
const { tags } = useItemTags('memo', itemId.toString());

// ✅ 正解: memo-editor と同じロジックを使用  
const targetOriginalId = memo.originalId || memo.id.toString()
const { tags } = useItemTags('memo', targetOriginalId);
```

## 技術スタック

### データ取得
- **React Query**: キャッシュ管理とプリフェッチ
- **useQueries**: 複数メモのタグ情報並列プリフェッチ  
- **useItemTags**: 個別アイテムのタグ取得フック

### UI コンポーネント
- **TagDisplayToggle**: コントロールパネルの表示切り替えボタン
- **ItemTagsPrefetcher**: プリフェッチ専用コンポーネント（UIなし）
- **TAG_COLORS**: タグの統一カラーパレット

### API エンドポイント
- **GET /taggings**: クエリパラメータでフィルタリング
  - `targetType=memo&targetOriginalId=123`

## React Query キャッシュキー体系

### データ別キャッシュキー設計

```typescript
// ボード関連
["item-boards", itemType, item.id]
// 例: ["item-boards", "memo", 123]

// タグ関連
['taggings', { targetType: itemType, targetOriginalId }]
// 例: ['taggings', { targetType: 'memo', targetOriginalId: '123' }]

// タグ一覧（管理画面用）
['tags', options] // { search?, sort?, limit? }
```

### キーの統一性
- **useItemBoards**: `["item-boards", itemType, item.id]`
- **usePrefetchItemBoards**: 同じキーでプリフェッチ → 完全にキャッシュ共有
- **useItemTags**: `['taggings', { targetType, targetOriginalId }]`  
- **usePrefetchItemTags**: 同じキーでプリフェッチ → 完全にキャッシュ共有

### 設計の利点
1. **キー統一**: プリフェッチと個別取得で同じキーを使用
2. **型安全**: TypeScript で厳密に型定義
3. **階層構造**: データ種別 → アイテム種別 → IDの階層

## 表示パターン例

```
[Board1]                          // ボードのみ
[tag1] [tag2]                     // タグのみ  
[Board1] [tag1] [tag2]            // 両方
[Board1] タグなし                   // ボードあり、タグなし
タグなし                           // 両方なし（タグ表示ON時）
```

## 実装完了項目 ✅

1. **データ取得基盤**: プリフェッチ + キャッシュ仕組み
2. **UI実装**: コントロールパネル + 一覧表示  
3. **デザイン統一**: TAG_COLORS による色の統一
4. **パフォーマンス**: N+1問題解決、キャッシュ最適化
5. **originalId統一**: メモエディターと同じロジック採用

## 今後の拡張ポイント

- タスク一覧でも同じ仕組みを適用可能
- ボード詳細でもタグ表示可能
- タグクリックでフィルタリング機能追加可能

**状況**: ✅ **実装完了** - メモ一覧でタグ表示が完全に動作