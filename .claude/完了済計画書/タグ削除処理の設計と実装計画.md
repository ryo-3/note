# タグ削除処理の設計と実装計画

## 現状の問題

### 問題点

- メモ削除時にタグ付け（taggings）が孤立したレコードとして残る
- `targetOriginalId`に外部キー制約がないため、自動削除されない
- 復元時の整合性とデータクリーンアップのバランスが取れていない

### 重要な前提

- **タグ本体（tags）**: 削除されたメモに関連していても保持する
- **タグ付け関係（taggings）**: 完全削除時のみクリーンアップ対象
- **originalId**: 削除→復元を通じて永続的に保持される
- **削除状態管理**: taggingsに新フィールド追加せず、既存テーブル構造のまま

### 現在のスキーマ

```sql
taggings {
  tagId: foreign key → tags.id (CASCADE削除あり)
  targetOriginalId: string (外部キー制約なし) ← 問題箇所
}
```

## 設計方針

### 基本ルール

1. **通常削除時（ゴミ箱移動）**: タグ付けは保持 → 復元時に一緒に復元
2. **完全削除時（永久削除）**: タグ付けのみ削除 → タグ本体は保持してデータクリーンアップ

### 削除パターン別の動作

#### パターン1: 通常削除（memos → deleted_memos）

```
操作: メモをゴミ箱に移動
├─ memos テーブルからレコード削除
├─ deleted_memos テーブルにレコード挿入
└─ taggings は**保持**（targetOriginalId同じ値で継続）

復元時:
├─ deleted_memos からレコード削除
├─ memos テーブルに戻す（originalId保持）
└─ taggings は既存のまま（originalIdベースで自動的に有効化）

フロントエンド表示:
└─ memosテーブルのoriginalIdとtaggingsのtargetOriginalIdを照合
   → 削除されたメモのタグは自動的に非表示
```

#### パターン2: 完全削除（deleted_memos → 完全消去）

```
操作: ゴミ箱から永久削除
├─ deleted_memos テーブルからレコード削除
├─ taggings から該当レコードを**削除**
└─ tags テーブルは**保持**（他のメモで再利用可能）

理由: 復元の可能性がないためタグ付けをクリーンアップ、タグ本体は保持
メリット: テーブル構造変更不要、originalIdベースの自動関連付け
```

## 実装計画

### Phase 1: API修正

#### 1.1 完全削除API の修正

**ファイル**: `apps/api/src/routes/memos/api.ts`

**対象エンドポイント**: `DELETE /memos/:id/permanent`

**修正内容**:

```typescript
// Before
await db.delete(deletedMemos).where(eq(deletedMemos.originalId, originalId));

// After
await db.transaction(async (tx) => {
  // 1. タグ付けを削除（タグ本体は保持）
  await tx
    .delete(taggings)
    .where(
      and(
        eq(taggings.targetType, "memo"),
        eq(taggings.targetOriginalId, originalId),
      ),
    );

  // 2. メモを削除
  await tx
    .delete(deletedMemos)
    .where(
      and(
        eq(deletedMemos.originalId, originalId),
        eq(deletedMemos.userId, auth.userId),
      ),
    );
});
```

#### 1.2 一括完全削除API の修正

**対象エンドポイント**: `DELETE /memos/permanent-bulk`

**修正内容**: 複数メモのoriginalIdを収集してタグ付けを一括削除（タグ本体は保持）

### Phase 2: フロントエンド確認

#### 2.1 削除フロー確認

- **通常削除**: memo-editor, memo-screen → タグ付けは自動で保持される ✅
- **完全削除**: deleted-memo-viewer → API修正で対応 ✅

#### 2.2 復元フロー確認

- 復元時にタグが正しく表示されるか検証

### Phase 3: データ整合性確保

#### 3.1 既存データのクリーンアップ

```sql
-- 孤立タグ付けの確認クエリ
SELECT t.* FROM taggings t
WHERE t.targetType = 'memo'
AND NOT EXISTS (
  SELECT 1 FROM memos m WHERE m.id = CAST(t.targetOriginalId AS INTEGER)
  UNION
  SELECT 1 FROM deleted_memos dm WHERE dm.id = CAST(t.targetOriginalId AS INTEGER)
);
```

#### 3.2 データベースマイグレーション（オプション）

将来的に外部キー制約を追加する場合の準備

## 実装順序

### Step 1: 完全削除API修正 🔧

- [x] API修正箇所の特定
- [x] トランザクション処理の実装
- [x] エラーハンドリングの追加

### Step 2: 一括削除API修正 🔧

- [x] 一括削除APIの存在確認（存在しないことを確認）
- [x] パフォーマンス最適化（不要）

### Step 3: フロントエンドバグ修正 🐛

- [x] usePrefetchItemTags でのoriginalIdフォールバック処理追加
- [x] memo-editor でのoriginalIdフォールバック処理追加
- [x] タグ表示ロジックの統一

### Step 4: テスト・検証 ✅

- [ ] 通常削除 → 復元のフロー確認
- [ ] 完全削除時のタグクリーンアップ確認

### Step 5: 既存データクリーンアップ 🧹

- [ ] 孤立タグ付けの調査
- [ ] 必要に応じてデータ修正

## 考慮事項

### メリット

✅ 復元時にタグが正しく復活する（originalIdベースの自動関連付け）  
✅ 完全削除時にタグ付けがクリーンアップされる  
✅ タグ本体は他のメモで再利用可能  
✅ テーブル構造変更不要（既存スキーマのまま）  
✅ 削除状態の追跡処理不要  
✅ 既存のフロントエンド処理は変更不要  
✅ バックエンドのみの修正で完結

### 注意点

⚠️ トランザクション処理でパフォーマンス影響を最小化  
⚠️ エラー時のロールバック処理を確実に  
⚠️ 大量削除時のタイムアウトに注意

## 完了判定基準

- [x] 通常削除後の復元でタグが保持される（フロントエンドバグ修正により実現）
- [x] 完全削除後にタグ付けレコードが存在しない（タグ本体は残存）
- [x] 一括削除は存在しないため対応不要
- [ ] 既存の削除済みメモに関連する孤立タグ付けがクリーンアップされる

## 実装完了項目

### バックエンド修正

- ✅ 完全削除API（DELETE /deleted/:originalId）にタグ付け削除処理を追加
- ✅ トランザクション処理でデータ整合性を保証
- ✅ エラーハンドリング実装済み

### フロントエンド修正

- ✅ usePrefetchItemTags の originalId フォールバック処理
- ✅ memo-editor の useItemTags 呼び出し修正
- ✅ memo-editor の updateTaggings 呼び出し修正
- ✅ タグ表示ロジックの統一

---

**実装担当**: Claude  
**レビュー**: User  
**想定工数**: 2-3時間  
**リスクレベル**: 低（バックエンドのみ、既存UIに影響なし）
