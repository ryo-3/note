# 全データ事前取得によるちらつき解消実装計画

## 🎯 目標
メモ一覧画面の初期化時に全関連データを一括取得し、ちらつきを完全解消する

## 現状の問題

### 1. ちらつきの原因
- **N+1問題**: メモ一覧表示時に各メモが個別にボード・タグ情報を取得
- **プリフェッチタイミング**: メモ取得後にプリフェッチ開始（後追い）
- **複雑な初期化**: MemoEditorでタグ初期化に複数useEffect + setTimeout使用
- **キャッシュミス**: 初回表示時にキャッシュが存在しない

### 2. 現在のデータフロー
```
1. メモ一覧取得 (useMemos)
2. メモ一覧表示（この時点でボード・タグ未取得）
3. プリフェッチ開始 (ItemBoardsPrefetcher, ItemTagsPrefetcher)
4. 各メモアイテムが個別API呼び出し（キャッシュミス）
5. エディター表示時にちらつき発生
```

## 解決方針

### 全データ事前取得方式
**メモ画面の初期化時に全ての関連データを一括取得**

```typescript
// 一度の初期化で全て取得
const { data: allTaggings } = useAllTaggings();     // 全タグ付け情報
const { data: allBoardItems } = useAllBoardItems(); // 全ボード紐付け情報
```

## 🔍 事前調査結果

### 既存APIの確認
1. **GET /taggings** - クエリパラメータなしで全件取得可能 ✅
2. **GET /boards/{id}/items** - ボード単位のアイテム取得（全件取得APIなし）❌
3. **GET /boards/items/{itemType}/{itemId}/boards** - アイテム単位のボード取得 ❌

### 課題
- **ボード紐付け情報の全件取得APIが存在しない**
- 各ボードごとにAPIを呼ぶ必要がある（ボード数分のAPIコール）

### 解決案
1. **案A**: 新規エンドポイント `/boards/all-items` を作成
2. **案B**: 既存の各ボードAPIを並列実行（ボード20個なら20並列）
3. **案C**: メモ側にボードID配列を持たせる（DB構造変更）

## 実装計画

### Phase 0: 影響範囲の詳細分析

#### 削除対象のコード
- [ ] `ItemBoardsPrefetcher` コンポーネント
- [ ] `ItemTagsPrefetcher` コンポーネント  
- [ ] `usePrefetchItemBoards` フック
- [ ] `usePrefetchItemTags` フック
- [ ] MemoEditorの複雑な初期化処理（useEffect × 5）

#### 修正対象のコード
- [ ] `MemoScreen` - 全データ取得追加
- [ ] `MemoListItem` - props方式に変更
- [ ] `MemoCard` - props方式に変更
- [ ] `MemoEditor` - 初期化簡素化
- [ ] `TaskScreen` - 同様の変更
- [ ] `BoardDetailScreen` - プリフェッチャー削除

### Phase 1: データ取得層の実装

#### 1.1 APIエンドポイント検討
- [ ] ボード紐付け全件取得の方法を決定
  - 案A採用の場合: 新規エンドポイント作成
  - 案B採用の場合: 並列取得ロジック実装

#### 1.2 新規フック作成
**ファイル**: `apps/web/src/hooks/use-all-data.ts`

```typescript
// 全タグ付け情報を取得
export function useAllTaggings() {
  const { getToken } = useAuth();
  
  return useQuery({
    queryKey: ['taggings', 'all'],
    queryFn: async () => {
      // 全タグ付け情報を取得
      const response = await fetch('/taggings?limit=10000');
      return response.json();
    },
    staleTime: 5 * 60 * 1000,  // 5分間キャッシュ
    gcTime: 30 * 60 * 1000,     // 30分間保持
  });
}

// 全ボード紐付け情報を取得
export function useAllBoardItems() {
  // 同様の実装
}
```

### Phase 2: データアクセス層の実装

#### 2.1 データ抽出ヘルパー関数
**ファイル**: `apps/web/src/utils/data-helpers.ts`

```typescript
// メモのタグを抽出
export function getMemoTags(
  memoOriginalId: string,
  allTaggings: Tagging[],
  allTags: Tag[]
): Tag[] {
  const taggings = allTaggings.filter(
    t => t.targetType === 'memo' && t.targetOriginalId === memoOriginalId
  );
  return taggings.map(t => allTags.find(tag => tag.id === t.tagId)).filter(Boolean);
}

// メモのボードを抽出
export function getMemoBoards(
  memoId: number,
  allBoardItems: BoardItem[],
  allBoards: Board[]
): Board[] {
  // 実装
}
```

### Phase 3: UI層の更新

#### 3.1 MemoScreen更新
```typescript
// 初期化時に全データ取得
const { data: memos } = useMemos();
const { data: allTags } = useTags();
const { data: allBoards } = useBoards();
const { data: allTaggings } = useAllTaggings();
const { data: allBoardItems } = useAllBoardItems();

// ローディング状態の統一管理
const isInitializing = !memos || !allTags || !allTaggings || !allBoardItems;
```

#### 3.2 MemoListItem簡素化
```typescript
// APIコール不要、propsで受け取る
interface MemoListItemProps {
  memo: Memo;
  tags: Tag[];        // 親から渡される
  boards: Board[];    // 親から渡される
  // ...
}
```

#### 3.3 MemoEditor簡素化
```typescript
// 複雑な初期化処理を削除
// propsまたはcontextでデータ受け取り
const tags = useMemo(() => {
  return getMemoTags(memo.originalId, allTaggings, allTags);
}, [memo.originalId, allTaggings, allTags]);
```

### Phase 4: パフォーマンス最適化

#### 4.1 遅延ローディング（オプション）
```typescript
// 初期表示用データ（最初の100件）
const { data: initialTaggings } = useInitialTaggings();

// バックグラウンドで残りを取得
useEffect(() => {
  if (initialTaggings) {
    prefetchRemainingTaggings();
  }
}, [initialTaggings]);
```

#### 4.2 メモ化の活用
```typescript
// 重い計算結果をメモ化
const memoTagsMap = useMemo(() => {
  const map = new Map<string, Tag[]>();
  memos?.forEach(memo => {
    map.set(memo.originalId, getMemoTags(memo.originalId, allTaggings, allTags));
  });
  return map;
}, [memos, allTaggings, allTags]);
```

## 実装順序と時間見積もり

### 🚨 重要な決定事項
**ボード紐付け情報の取得方法を決める必要がある**
- 新規API作成なら +1時間
- 既存API並列実行なら +30分
- DB構造変更なら +2時間

### 実装ステップ（既存API並列実行案の場合）

1. **準備** (10分)
   - [ ] 現在の実装をバックアップ
   - [ ] 開発ブランチ作成

2. **Phase 1: データ取得層** (1時間)
   - [ ] useAllTaggings フック作成（既存API使用）
   - [ ] useAllBoardItems フック作成（並列取得実装）
   - [ ] 動作確認・デバッグ

3. **Phase 2: データ抽出層** (30分)
   - [ ] getMemoTags ヘルパー関数
   - [ ] getMemoBoards ヘルパー関数
   - [ ] パフォーマンス最適化（Map使用）

4. **Phase 3: UI層更新** (2時間)
   - [ ] MemoScreen - 全データ取得・配布
   - [ ] MemoListItem - props受け取り方式
   - [ ] MemoCard - props受け取り方式
   - [ ] MemoEditor - 初期化処理削除
   - [ ] 動作確認

5. **Phase 4: クリーンアップ** (1時間)
   - [ ] プリフェッチャー削除
   - [ ] 不要なフック削除
   - [ ] import整理
   - [ ] 型定義整理

6. **Phase 5: テスト** (30分)
   - [ ] ちらつき解消確認
   - [ ] パフォーマンス測定
   - [ ] メモ100個でテスト
   - [ ] メモ1000個でテスト

**合計見積もり時間: 約5時間**

## 期待される効果

### パフォーマンス改善
- **APIコール削減**: 40回 → 2-4回
- **初回表示**: 400-2000ms → 100-200ms
- **スクロール時**: 追加API不要
- **エディター切替**: 即座に表示（ちらつきなし）

### コード簡素化
- MemoEditorの初期化処理: 100行 → 20行
- useEffect削減: 5個 → 1個
- setTimeout削除: 完全除去

### ユーザー体験向上
- ちらつき完全解消
- スムーズなスクロール
- 高速なエディター切替
- オフライン対応強化（キャッシュ充実）

## リスクと対策

### リスク
1. **初回ロード時間増加**
   - 対策: ローディング表示の改善
   - 対策: 段階的データ取得

2. **メモリ使用量増加**
   - 対策: 不要データの定期クリーンアップ
   - 対策: ページネーション併用

3. **データ同期の複雑化**
   - 対策: 適切なキャッシュ無効化
   - 対策: optimistic update活用

## 成功基準

- [ ] メモ一覧でちらつきが発生しない
- [ ] エディター表示が即座（100ms以内）
- [ ] 初回ロード時間が1秒以内
- [ ] メモ2000個でも快適動作

## 備考

- 実装中に問題が発生した場合は、段階的アプローチに切り替え
- タスク画面、ボード画面にも同様の方式を適用予定
- 将来的にはWebSocketでリアルタイム同期も検討