# データベーステーブル設計詳細

## 既存システムの整合性分析

### 既存パターンの統一
- **タイムスタンプ**: `integer`型 + `{ mode: "timestamp" }` + `sql`(unixepoch())`
- **ID**: `integer`型 + `primaryKey({ autoIncrement: true })`
- **ユーザーID**: `text("user_id").notNull()`
- **originalId**: `text("original_id").notNull()` (メモ・タスクのみ)
- **削除テーブル**: 元テーブル + `deletedAt`フィールド

## 1. タグシステム テーブル設計

### tagsテーブル (タグマスター)
```typescript
// apps/api/src/db/schema/tags.ts
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

export const tags = sqliteTable("tags", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  color: text("color"), // hex形式 例: "#3B82F6"
  userId: text("user_id").notNull(),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`)
    .$onUpdate(() => new Date()),
});

// ユニークインデックス: ユーザー毎にタグ名は一意
// CREATE UNIQUE INDEX idx_tags_user_name ON tags(user_id, name);
```

### taggingsテーブル (タグ付け中間テーブル)
```typescript
export const taggings = sqliteTable("taggings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  tagId: integer("tag_id").notNull().references(() => tags.id, { onDelete: "cascade" }),
  targetType: text("target_type").notNull(), // 'memo' | 'task' | 'board'
  targetOriginalId: text("target_original_id").notNull(), // 対象のoriginalId
  userId: text("user_id").notNull(), // パフォーマンス向上のため重複保存
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
});

// 複合ユニークインデックス: 同じアイテムに同じタグは1つまで
// CREATE UNIQUE INDEX idx_taggings_unique ON taggings(tag_id, target_type, target_original_id);
// 検索用インデックス
// CREATE INDEX idx_taggings_target ON taggings(target_type, target_original_id);
// CREATE INDEX idx_taggings_user ON taggings(user_id);
```

### 型定義
```typescript
export type Tag = typeof tags.$inferSelect;
export type NewTag = typeof tags.$inferInsert;
export type Tagging = typeof taggings.$inferSelect;
export type NewTagging = typeof taggings.$inferInsert;
```

## 2. ボードカテゴリー テーブル設計

### boardCategoriesテーブル
```typescript
// apps/api/src/db/schema/board-categories.ts
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

export const boardCategories = sqliteTable("board_categories", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  description: text("description"), // オプション
  color: text("color"), // hex形式 例: "#3B82F6"
  icon: text("icon"), // アイコン名 例: "folder", "project"
  sortOrder: integer("sort_order").notNull().default(0), // 表示順序
  userId: text("user_id").notNull(),
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`)
    .$onUpdate(() => new Date()),
});

// ユニークインデックス: ユーザー毎にカテゴリー名は一意
// CREATE UNIQUE INDEX idx_board_categories_user_name ON board_categories(user_id, name);
// 並び順用インデックス
// CREATE INDEX idx_board_categories_sort ON board_categories(user_id, sort_order);
```

### boardsテーブル拡張
```typescript
// apps/api/src/db/schema/boards.ts に追加
export const boards = sqliteTable("boards", {
  // 既存フィールド...
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  slug: text("slug").notNull().unique(),
  description: text("description"),
  userId: text("user_id").notNull(),
  archived: integer("archived", { mode: "boolean" }).notNull().default(false),
  completed: integer("completed", { mode: "boolean" }).notNull().default(false),
  
  // 新規追加
  boardCategoryId: integer("board_category_id").references(() => boardCategories.id, { onDelete: "set null" }),
  
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .default(sql`(unixepoch())`)
    .$onUpdate(() => new Date()),
});

// インデックス追加
// CREATE INDEX idx_boards_category ON boards(board_category_id);
```

### deletedBoardsテーブル拡張
```typescript
export const deletedBoards = sqliteTable("deleted_boards", {
  // 既存フィールド...
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id").notNull(),
  originalId: integer("original_id").notNull(), // 元のboardsテーブルのID
  name: text("name").notNull(),
  slug: text("slug").notNull(),
  description: text("description"),
  archived: integer("archived", { mode: "boolean" }).notNull(),
  
  // 新規追加
  boardCategoryId: integer("board_category_id"), // 削除時にカテゴリー情報も保存
  
  createdAt: integer("created_at").notNull(),
  updatedAt: integer("updated_at"),
  deletedAt: integer("deleted_at").notNull(), // 削除日時
});
```

### 型定義
```typescript
export type BoardCategory = typeof boardCategories.$inferSelect;
export type NewBoardCategory = typeof boardCategories.$inferInsert;

// Board型の拡張（関連データ含む）
export type BoardWithCategory = Board & {
  boardCategory?: BoardCategory;
};
```

## 3. 重要な設計判断

### originalIdの扱い
- **ボード**: 既存システムでは`boards.id`を直接使用
- **タグ付け**: `targetOriginalId`でメモ・タスク・ボードを統一的に扱う
- **ボードのoriginalId**: `board.id.toString()`として生成

### タイムスタンプの統一
```typescript
// 既存パターンに合わせた統一形式
createdAt: integer("created_at", { mode: "timestamp" })
  .notNull()
  .default(sql`(unixepoch())`),
updatedAt: integer("updated_at", { mode: "timestamp" })
  .notNull()
  .default(sql`(unixepoch())`)
  .$onUpdate(() => new Date()),
```

### 外部キー制約の戦略
- **tags → taggings**: `onDelete: "cascade"` (タグ削除時にタグ付けも削除)
- **boardCategories → boards**: `onDelete: "set null"` (カテゴリー削除時にボードは未分類)

### インデックス戦略
```sql
-- タグ系
CREATE UNIQUE INDEX idx_tags_user_name ON tags(user_id, name);
CREATE UNIQUE INDEX idx_taggings_unique ON taggings(tag_id, target_type, target_original_id);
CREATE INDEX idx_taggings_target ON taggings(target_type, target_original_id);
CREATE INDEX idx_taggings_user ON taggings(user_id);

-- ボードカテゴリー系  
CREATE UNIQUE INDEX idx_board_categories_user_name ON board_categories(user_id, name);
CREATE INDEX idx_board_categories_sort ON board_categories(user_id, sort_order);
CREATE INDEX idx_boards_category ON boards(board_category_id);
```

## 4. Drizzleスキーマファイル構成

### ファイル構造
```
apps/api/src/db/schema/
├── memos.ts              # 既存
├── tasks.ts              # 既存  
├── boards.ts             # 既存 + boardCategoryId追加
├── categories.ts         # 既存
├── user-preferences.ts   # 既存
├── tags.ts               # 新規
└── board-categories.ts   # 新規
```

### index.tsの更新
```typescript
// apps/api/src/db/index.ts
export * from "./schema/memos";
export * from "./schema/tasks";
export * from "./schema/user-preferences";
export * from "./schema/categories";
export * from "./schema/boards";
export * from "./schema/tags";              // 新規追加
export * from "./schema/board-categories";  // 新規追加
```

## 5. マイグレーション考慮事項

### 段階的追加戦略
1. **Phase 1**: `tags`, `taggings`テーブル作成
2. **Phase 2**: `board_categories`テーブル作成  
3. **Phase 3**: `boards`テーブルに`board_category_id`追加
4. **Phase 4**: `deleted_boards`テーブルに`board_category_id`追加

### 既存データへの影響
- 既存のmemos, tasks, boardsテーブルは変更なし
- 新規テーブルのみ追加で、後方互換性確保
- `boards.boardCategoryId`は`NULL`許可で既存データ影響なし

## 6. パフォーマンス最適化

### クエリパターン最適化
```sql
-- よく使われるクエリパターン
-- 1. 特定アイテムのタグ一覧
SELECT t.* FROM tags t 
JOIN taggings tg ON t.id = tg.tag_id 
WHERE tg.target_type = ? AND tg.target_original_id = ?;

-- 2. 特定タグのアイテム一覧
SELECT tg.target_type, tg.target_original_id 
FROM taggings tg 
WHERE tg.tag_id = ?;

-- 3. カテゴリー別ボード一覧
SELECT b.*, bc.name as category_name 
FROM boards b 
LEFT JOIN board_categories bc ON b.board_category_id = bc.id 
WHERE b.board_category_id = ?;
```

### メモリ使用量対策
- `userId`の重複保存でJOIN回数削減
- 適切なインデックスでテーブルスキャン回避
- ページネーション前提の設計

## 7. 実装優先順位

### 必須実装
1. `tags`テーブル + 基本CRUD
2. `taggings`テーブル + 基本操作
3. `board_categories`テーブル + 基本CRUD
4. `boards.boardCategoryId`追加

### 段階的実装
1. メモ・タスクのタグ機能
2. ボードのタグ機能  
3. ボードカテゴリー機能
4. 横断検索機能

この設計で問題ありませんか？特に気になる点や変更したい部分があればお知らせください。