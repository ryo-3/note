import { useEffect } from 'react'
import { useDeleteTask, usePermanentDeleteTask } from '@/src/hooks/use-tasks'
import { useBulkDelete, BulkDeleteConfirmation } from '@/components/ui/modals'
import type { Task, DeletedTask } from '@/src/types/task'
import React from 'react'
import { useMutation } from '@tanstack/react-query'
import { useAuth } from '@clerk/nextjs'
import { tasksApi } from '@/src/lib/api-client'
import { useBulkAnimation } from '@/src/hooks/use-bulk-animation'
import { executeWithAnimation } from '@/src/utils/bulkAnimationUtils'
import { DeletionWarningMessage } from '@/components/ui/modals/deletion-warning-message'

interface UseTasksBulkDeleteProps {
  activeTab: 'todo' | 'in_progress' | 'completed' | 'deleted'
  checkedTasks: Set<number>
  checkedDeletedTasks: Set<number>
  setCheckedTasks: (tasks: Set<number>) => void
  setCheckedDeletedTasks: (tasks: Set<number>) => void
  tasks?: Task[]
  deletedTasks?: DeletedTask[]
  onTaskDelete?: (id: number) => void
  deleteButtonRef?: React.RefObject<HTMLButtonElement | null>
  setIsDeleting?: (isDeleting: boolean) => void
  setIsLidOpen?: (isOpen: boolean) => void
  viewMode?: 'list' | 'card'
}

export function useTasksBulkDelete({
  activeTab,
  checkedTasks,
  checkedDeletedTasks,
  setCheckedTasks,
  setCheckedDeletedTasks,
  tasks,
  deletedTasks,
  onTaskDelete,
  deleteButtonRef,
  setIsDeleting,
  setIsLidOpen,
  viewMode = 'list' // eslint-disable-line @typescript-eslint/no-unused-vars
}: UseTasksBulkDeleteProps) {
  const deleteTaskMutation = useDeleteTask()
  const permanentDeleteTaskMutation = usePermanentDeleteTask()
  const bulkDelete = useBulkDelete()
  const { getToken } = useAuth()
  
  // Ëá™ÂãïÊõ¥Êñ∞„Å™„Åó„ÅÆÂâäÈô§API - ‰ªäÂæå„ÅÆÊúÄÈÅ©Âåñ„Åß‰ΩøÁî®‰∫àÂÆö
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const deleteTaskWithoutUpdate = useMutation({
    mutationFn: async (id: number) => {
      const token = await getToken()
      const response = await tasksApi.deleteTask(id, token || undefined)
      return response.json()
    },
    // onSuccess„Å™„ÅóÔºàËá™ÂãïÊõ¥Êñ∞„Åó„Å™„ÅÑÔºâ
  })
  
  // Ëá™ÂãïÊõ¥Êñ∞„Å™„Åó„ÅÆÂÆåÂÖ®ÂâäÈô§API - ‰ªäÂæå„ÅÆÊúÄÈÅ©Âåñ„Åß‰ΩøÁî®‰∫àÂÆö
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const permanentDeleteTaskWithoutUpdate = useMutation({
    mutationFn: async (id: number) => {
      const token = await getToken()
      const response = await tasksApi.permanentDeleteTask(id, token || undefined)
      return response.json()
    },
    // onSuccess„Å™„ÅóÔºàËá™ÂãïÊõ¥Êñ∞„Åó„Å™„ÅÑÔºâ
  })
  
  // ÂÖ±ÈÄö„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
  const bulkAnimation = useBulkAnimation({
    checkedItems: checkedTasks,
    checkedDeletedItems: checkedDeletedTasks,
  })

  // „ÉÅ„Çß„ÉÉ„ÇØÁä∂ÊÖã„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó - ÂâäÈô§„Åï„Çå„Åü„Çø„Çπ„ÇØ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„ÇíËß£Èô§ÔºàÈÉ®ÂàÜÂâäÈô§‰∏≠„ÅØÁÑ°ÂäπÔºâ
  useEffect(() => {
    if (tasks && !bulkAnimation.isPartialProcessing) {
      const allTaskIds = new Set(tasks.map(t => t.id))
      const newCheckedTasks = new Set(Array.from(checkedTasks).filter(id => allTaskIds.has(id)))
      if (newCheckedTasks.size !== checkedTasks.size) {
        setCheckedTasks(newCheckedTasks)
      }
    }
  }, [tasks, checkedTasks, setCheckedTasks, bulkAnimation.isPartialProcessing])

  // ÂâäÈô§‰∏≠„Éï„É©„Ç∞„ÇíÂ§ñÈÉ®„ÅßÁÆ°ÁêÜ
  const isCurrentlyDeleting = deleteTaskMutation.isPending || permanentDeleteTaskMutation.isPending
  
  useEffect(() => {
    // ÂâäÈô§‰∏≠„ÅØËá™Âãï„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÇíÁÑ°Âäπ„Å´„Åô„ÇãÔºàÈÉ®ÂàÜÂâäÈô§‰∏≠„ÇÇÁÑ°ÂäπÔºâ
    if (deletedTasks && !isCurrentlyDeleting && !bulkAnimation.isPartialProcessing) {
      const deletedTaskIds = new Set(deletedTasks.map(t => t.id))
      const newCheckedDeletedTasks = new Set(Array.from(checkedDeletedTasks).filter(id => deletedTaskIds.has(id)))
      if (newCheckedDeletedTasks.size !== checkedDeletedTasks.size) {
        setCheckedDeletedTasks(newCheckedDeletedTasks)
      }
    }
  }, [deletedTasks, checkedDeletedTasks, setCheckedDeletedTasks, isCurrentlyDeleting, bulkAnimation.isPartialProcessing])

  // ÂÖ±ÈÄö„ÅÆÂâäÈô§Âá¶ÁêÜÈñ¢Êï∞ÔºàÂÖ±ÈÄö„É≠„Ç∏„ÉÉ„ÇØ‰ΩøÁî®Ôºâ
  const executeDeleteWithAnimation = async (
    ids: number[],
    isPartialDelete = false,
    originalTotalCount?: number
  ) => {
    const onStateUpdate = (id: number) => {
      if (activeTab !== "deleted" && onTaskDelete) {
        onTaskDelete(id)
      }
    }

    const onCheckStateUpdate = (ids: number[], isPartial: boolean) => {
      if (isPartial) {
        if (activeTab === "deleted") {
          const newCheckedDeletedTasks = new Set(checkedDeletedTasks)
          ids.forEach((id) => newCheckedDeletedTasks.delete(id))
          setCheckedDeletedTasks(newCheckedDeletedTasks)
        } else {
          const newCheckedTasks = new Set(checkedTasks)
          ids.forEach((id) => newCheckedTasks.delete(id))
          setCheckedTasks(newCheckedTasks)
        }
      } else {
        if (activeTab === "deleted") {
          setCheckedDeletedTasks(new Set())
        } else {
          setCheckedTasks(new Set())
        }
      }
    }

    const onApiCall = async (id: number) => {
      if (activeTab === "deleted") {
        await permanentDeleteTaskMutation.mutateAsync(id)
      } else {
        await deleteTaskMutation.mutateAsync(id)
      }
    }

    await executeWithAnimation({
      ids,
      isPartial: isPartialDelete,
      originalTotalCount,
      buttonRef: deleteButtonRef,
      dataAttribute: "data-task-id",
      onStateUpdate,
      onCheckStateUpdate,
      onApiCall,
      initializeAnimation: bulkAnimation.initializeAnimation,
      startCountdown: bulkAnimation.startCountdown,
      finalizeAnimation: bulkAnimation.finalizeAnimation,
      setIsProcessing: setIsDeleting,
      setIsLidOpen,
    })
  }

  // „Çπ„ÉÜ„Éº„Çø„ÇπÂà•„Ç´„Ç¶„É≥„Éà„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
  const getStatusBreakdown = (taskIds: number[]) => {
    if (activeTab === "deleted") {
      return [{ status: 'deleted', label: 'ÂâäÈô§Ê∏à„Åø', count: taskIds.length, color: 'bg-red-600' }];
    }
    
    const allTasks = tasks || [];
    const selectedTasks = allTasks.filter(task => taskIds.includes(task.id));
    
    const todoCount = selectedTasks.filter(task => task.status === 'todo').length;
    const inProgressCount = selectedTasks.filter(task => task.status === 'in_progress').length;
    const completedCount = selectedTasks.filter(task => task.status === 'completed').length;
    
    const breakdown = [];
    if (todoCount > 0) breakdown.push({ status: 'todo', label: 'Êú™ÁùÄÊâã', count: todoCount, color: 'bg-zinc-400' });
    if (inProgressCount > 0) breakdown.push({ status: 'in_progress', label: 'ÈÄ≤Ë°å‰∏≠', count: inProgressCount, color: 'bg-Blue' });
    if (completedCount > 0) breakdown.push({ status: 'completed', label: 'ÂÆå‰∫Ü', count: completedCount, color: 'bg-Green' });
    
    return breakdown;
  };

  // „Ç´„Çπ„Çø„É†„É°„ÉÉ„Çª„Éº„Ç∏„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
  const TaskDeleteMessage = ({ taskIds, currentTabTaskIds }: { taskIds: number[]; currentTabTaskIds: number[] }) => {
    const allStatusBreakdown = getStatusBreakdown(taskIds);
    const currentTabStatusBreakdown = getStatusBreakdown(currentTabTaskIds);
    const isLimited = currentTabTaskIds.length > 100;
    
    // ‰ªñ„ÅÆ„Çø„Éñ„Å´„ÇÇÈÅ∏Êäû„Ç¢„Ç§„ÉÜ„É†„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÂâäÈô§Ê∏à„Åø„Çø„Éñ„ÅÆÂ†¥Âêà„ÅØÈÄöÂ∏∏„Çø„Éñ„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºâ
    const hasOtherTabItems = activeTab === "deleted" 
      ? checkedTasks.size > 0 
      : taskIds.length > currentTabTaskIds.length;
    
    return (
      <DeletionWarningMessage
        hasOtherTabItems={hasOtherTabItems}
        isLimited={isLimited}
        statusBreakdown={hasOtherTabItems ? currentTabStatusBreakdown : allStatusBreakdown}
        showStatusBreakdown={true}
      />
    );
  };

  const handleBulkDelete = async () => {
    const rawTargetIds = activeTab === "deleted" 
      ? Array.from(checkedDeletedTasks)
      : Array.from(checkedTasks)

    // ÁèæÂú®„ÅÆ„Çø„Éñ„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã„Çø„Çπ„ÇØ„ÅÆID„ÅÆ„Åø„ÇíÊäΩÂá∫
    const { getTaskDisplayOrder } = await import('@/src/utils/domUtils');
    const domOrder = getTaskDisplayOrder();
    const currentTabTaskIds = rawTargetIds.filter(id => domOrder.includes(id));
    
    // DOMÈ†ÜÂ∫è„Åß„ÇΩ„Éº„Éà
    const targetIds = currentTabTaskIds.sort((a, b) => {
      const aIndex = domOrder.indexOf(a);
      const bIndex = domOrder.indexOf(b);
      if (aIndex === -1) return 1;
      if (bIndex === -1) return -1;
      return aIndex - bIndex;
    });

    // „Çø„Çπ„ÇØ„ÅÆÂ†¥Âêà„ÅØ1‰ª∂„Åã„Çâ„É¢„Éº„ÉÄ„É´Ë°®Á§∫ÔºàÂâäÈô§Ê∏à„Åø„ÉªÈÄöÂ∏∏Âïè„Çè„ÅöÔºâ
    const threshold = 1
    
    // 100‰ª∂Ë∂Ö„Åà„ÅÆÂ†¥Âêà„ÅØÊúÄÂàù„ÅÆ100‰ª∂„ÅÆ„ÅøÂá¶ÁêÜÔºàDOMÈ†ÜÂ∫è„Åß„ÅÆÊúÄÂàù„ÅÆ100‰ª∂Ôºâ
    const actualTargetIds = targetIds.length > 100 ? targetIds.slice(0, 100) : targetIds
    const isLimitedDelete = targetIds.length > 100

    // ÂâäÈô§„Éú„Çø„É≥„ÇíÊäº„Åó„ÅüÁû¨Èñì„ÅÆÁä∂ÊÖãË®≠ÂÆöÔºà„Ç´„Ç¶„É≥„Çø„ÉºÁ∂≠ÊåÅÔºâ
    bulkAnimation.setModalState(setIsDeleting, setIsLidOpen)

    // console.log('üóëÔ∏è ÂâäÈô§ÈñãÂßã:', { 
    //   selected: targetIds.length, 
    //   actualDelete: actualTargetIds.length, 
    //   activeTab,
    //   isLimited: isLimitedDelete 
    // })
    
    if (isLimitedDelete) {
      // 100‰ª∂Âà∂Èôê„ÅÆ„É¢„Éº„ÉÄ„É´Ë°®Á§∫
      await bulkDelete.confirmBulkDelete(
        actualTargetIds, 
        0, // Âç≥Â∫ß„Å´„É¢„Éº„ÉÄ„É´Ë°®Á§∫
        async (ids: number[], isPartialDelete = false) => {
          await executeDeleteWithAnimation(ids, isPartialDelete, targetIds.length);
        },
        <TaskDeleteMessage taskIds={rawTargetIds} currentTabTaskIds={targetIds} />,
        true // isPartialDelete
      )
    } else {
      // ÈÄöÂ∏∏„ÅÆÁ¢∫Ë™ç„É¢„Éº„ÉÄ„É´
      await bulkDelete.confirmBulkDelete(
        actualTargetIds, 
        threshold, 
        async (ids: number[]) => {
          await executeDeleteWithAnimation(ids);
        },
        <TaskDeleteMessage taskIds={rawTargetIds} currentTabTaskIds={targetIds} />
      )
    }
  }

  const DeleteModal = () => {
    const customTitle = activeTab === "deleted" 
      ? "„Çø„Çπ„ÇØ„ÅÆÂÆåÂÖ®ÂâäÈô§" 
      : "„Çø„Çπ„ÇØ„ÇíÂâäÈô§";
    
    
    return (
      <BulkDeleteConfirmation
        isOpen={bulkDelete.isModalOpen}
        onClose={() => {
          bulkAnimation.handleModalCancel(setIsDeleting, setIsLidOpen)
          bulkDelete.handleCancel()
        }}
        onConfirm={async () => {
          // console.log('Confirm modal')
          await bulkDelete.handleConfirm()
        }}
        count={bulkDelete.targetIds.length}
        itemType="task"
        deleteType={activeTab === "deleted" ? "permanent" : "normal"}
        isLoading={bulkDelete.isDeleting}
        customMessage={bulkDelete.customMessage}
        customTitle={customTitle}
      />
    );
  };

  // ÁèæÂú®„ÅÆ„Çø„Éñ„ÅßÂâäÈô§ÂØæË±°„Å®„Å™„Çã„Çø„Çπ„ÇØ„ÅÆÊï∞„ÇíË®àÁÆó
  const getCurrentTabDeleteCount = () => {
    if (activeTab === "deleted") {
      return checkedDeletedTasks.size;
    }
    
    // ÈÄöÂ∏∏„Çø„Éñ„ÅÆÂ†¥Âêà„ÄÅÁèæÂú®Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã„Çø„Çπ„ÇØ„ÅÆ„ÅÜ„Å°ÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÅÆ„Åø„Ç´„Ç¶„É≥„Éà
    const allTasks = tasks || [];
    const currentTabTasks = allTasks.filter(task => task.status === activeTab);
    const currentTabTaskIds = currentTabTasks.map(task => task.id);
    const selectedCurrentTabTasks = Array.from(checkedTasks).filter(id => currentTabTaskIds.includes(id));
    
    return selectedCurrentTabTasks.length;
  };

  // ÁèæÂú®„ÅÆÂâäÈô§„Ç´„Ç¶„É≥„ÉàÔºàÈÄöÂ∏∏ÊôÇ„ÅØÁèæÂú®„ÅÆ„Çø„Éñ„ÅÆ‰ª∂Êï∞„ÄÅÂâäÈô§‰∏≠„ÅØ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®Ôºâ
  const currentDeleteCount = getCurrentTabDeleteCount();
  const finalDisplayCount = bulkAnimation.isCountingActive
    ? bulkAnimation.displayCount
    : currentDeleteCount

  // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
  // console.log('üîÑ ÂâäÈô§„Ç´„Ç¶„É≥„Çø„ÉºÁä∂ÊÖã:', {
  //   activeTab,
  //   isCountingActive: bulkAnimation.isCountingActive,
  //   displayCount: bulkAnimation.displayCount,
  //   currentDeleteCount,
  //   finalDisplayCount,
  //   checkedTasksSize: checkedTasks.size,
  //   checkedDeletedTasksSize: checkedDeletedTasks.size
  // })

  return {
    handleBulkDelete,
    DeleteModal,
    // „Ç´„Ç¶„É≥„Çø„Éº„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊôÇ„ÅØdisplayCount„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØÂÆüÈöõ„ÅÆ„Ç´„Ç¶„É≥„Éà
    currentDisplayCount: finalDisplayCount,
  }
}